# Material Design
This lecture discusses [Material design](https://material.io/guidelines/material-design/introduction.html): the _design language_ created by Google to support mobile user interfaces. The design language focuses on mobile designs (e.g., for Android), but can also be used across platforms (e.g., on the web through [css frameworks]()).

<p class="alert alert-info">This lecture references code found at <https://github.com/info448-s17/lecture14-material>.</p>

## The Material Design Language `r#[15-20min]`
See video: https://www.youtube.com/watch?v=YaG_ljfzeUw (via https://developer.android.com/design/material/index.html)

Summary:
- based on "materials": in particular, idea of surfaces (pieces of paper) floating in space
  - uniform thickness (1dp), but at different elevations (depths)
    - Each element ahs default resting elevation, but can change in response to user input
      - use shadows to indicate current elevation
      - Helps to indicate _perspective_
    - don't occupy same space!
  - can change shape, size, position (along plane); but doesn't fold; can split and rejoin
  - motion/interaction: inputs stay within material, material doesn't pass through materials
    - can move on any axis, but z-axis (up and down) is for user interaction!
- aesthetic choices (color, fonts, etc)
- motion within a single environment: content moves and reorganizes in response to user input
- **Object Hierarchy**; group visual components into hierarchy (parent-child), with some rules:
  - children move with parent (e.g., scrolling); includes transformations (scales, elevation changes, etc)
  - children have minimal elevation diff from parents, and other objects don't get inserted inbetween
  - Note: this may not correspond to an actual View hierarchy!

Links:
- https://material.io/guidelines/material-design/introduction.html#introduction-principles
- **https://material.io/guidelines/material-design/material-properties.html**
- **https://material.io/guidelines/material-design/elevation-shadows.html#elevation-shadows-elevation-android**

Note: talked about using material theme/styling in lab!
- Have included a few theme tricks (can go over)

## Design Support Library
Include it:

```
compile 'com.android.support:design:25.3.1'
```

### Fabs
- basically a "styled" button... but also will have extra benefits later!
  - e.g., snackbar with coordinatorLayout

### Cards
```
compile 'com.android.support:cardview-v7:25.3.1'
```

different library, but still support
- include an image in the card?


### Navigation Drawers
- add extra wrapping


### CoordinationLayout
- create a scrolling activity, look at that!
  - Intent our way to it
- can build a coodinator layout into Main and see how it works (sorta...) :)


## Material Animations

### Transitions
```xml
<!-- in style: enable window content transitions -->
<item name="android:windowActivityTransitions">true</item>
```

Make buttons map:
- add `android:transitionName` to each
- wrap scrollview `anchor` in FrameLayout

```java
ActivityOptions options = ActivityOptions.makeSceneTransitionAnimation(MainActivity.this, fab, "fab"); //for single item
// start the new activity
startActivity(new Intent(MainActivity.this, ScrollingActivity.class), options.toBundle());
```


### Property Animation (a ball)
We've seen how we can create animations simply by adjusting the drawing we do on each frame. This is great for games or other complex animations if we want to have _a lot_ of control over our graphical layout... but sometimes we want to have some simpler, platform-specific effects (that run smoother!) Android actually involves a number of different animation systems that can be used within and _across_ Views:

[Property Animation](http://developer.android.com/guide/topics/graphics/prop-animation.html) is a general animation framework, that basically performs animated _linear interpolation_ on whatever values you give it to change.
- We'll go over this in a second

[Scene Transitions](http://developer.android.com/training/transitions/index.html) are a framework for transitioning between layouts; the material animations use this indirectly. See also [Animations](http://developer.android.com/training/animation/index.html)
- These are useful and able to be added to really any application... but are "extra flair" rather than being core to something like games, so I'll leave you to look up these systems on your own.
- [Material Animations](http://developer.android.com/training/material/animations.html) include animations built into the "material design" style (found in Lollipop and later), and include various effects and transitions in response to user interaction (e.g., ripples, sliding fragments, etc).

[OpenGL Animations](http://developer.android.com/guide/topics/graphics/opengl.html) are available for doing 3D animated systems.

...and there might be a few others out there as well. A good place to start if you're interested in adding animations and transitions to your app is the [Material Design Guide](http://developer.android.com/design/index.html), particularly the [animation section](https://www.google.com/design/spec/animation/authentic-motion.html). This has a lot of _design_ guidelines to make sure you're actually adding _useful_ animations.

We're going to focus on **Property Animation** as an example---in part since you can potentially use it for your homework. It also requires less setup. [Property Animation](http://developer.android.com/guide/topics/graphics/prop-animation.html) is an animation system where you specify a start state, an end state, and a duration, and the Android systems changes from the start to the end over that length of time--thereby producing animation!
- This is calculated using a concept called [interpolation](https://en.wikipedia.org/wiki/Interpolation); most usually a variation of **linear interpolation**.
  - Anyone done linear algebra? Fun aside! Basically, we figure out how far along we are in the animation, and then take that a _weighted average_ of the start and end values. We can get _non-linear interpolation_ by adjusting the weights so they are non-linear (e.g., you need to get 70% across to have 50% of the starting value).

The main engine for doing this kind of interpolated animation in Android is the [`ValueAnimator`](http://developer.android.com/guide/topics/graphics/prop-animation.html#value-animator) class. This class lets you specify the start, end, and duration, and then can be run to calculate all the values in between. It has a number of static methods (e.g., `.ofInt`, `.ofFloat`, `.ofArgb`) which creates "animators" for interpolating different _values_. For example:
```java
ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);
animation.setDuration(1000);
animation.start();
```
- Of course, just running this doesn't do anything we can see, since it's change the numbers but those don't relate to anything! We can get the values by setting a [listener](http://developer.android.com/guide/topics/graphics/prop-animation.html#listeners) and overriding a callback we're interested in (e.g., `onAnimationUpdate()` from `ValueAnimator.AnimatorUpdateListener`).

But more commonly, we want to have our animation change the _property_ of some object--for example, the color of a view, the position of an object (like a ball), etc. We can do this easily using the [`ObjectAnimator`](http://developer.android.com/guide/topics/graphics/prop-animation.html#object-animator) subclass. Basically, this subclass runs an animation like the `ValueAnimator`, but has the built-in functionality to change the property of an object on each step.
- It does this by calling a **setter** for that property---thus the object needs to have a property setter for us to animate it! (If not, we can make a wrapper or just develop our on `ValueAnimator`).
```java
//change the "alpha" property of foo (e.g., call foo.setAlpha())
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, "alpha", 0f, 1f);
anim.setDuration(1000);
anim.start();
```

We can use this to (say) change the ball's radius or position using an interpolated animation. Other options:
- Make a _getter_ and only pass the Animator an ending value if we want (so "from current to end")
- Use `.setRepeatCount(INFINITE)` and `.setRepeatMode(REVERSE)` to cause it to repeat!
- Note that we're changing the property, and because our `SurfaceView` is refreshing all the time, we get to see the updates in action :)

If we want to include multiple animations in sequence, we can use an [`AnimatorSet`](http://developer.android.com/guide/topics/graphics/prop-animation.html#choreography), which gives us methods about the ordering:
```java
//example from docs
ObjectAnimator animX = ObjectAnimator.ofFloat(obj, "x", 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(obj, "y", 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
```

These can get complicated, and we may want to reuse them... so we can also defining them in XML as [resources](http://developer.android.com/guide/topics/graphics/prop-animation.html#declaring-xml). This also means that we can have different configurations use different animations (perhaps things move faster on a larger phone?).
- These are put into the `/res/animator` directory (**not** the `/res/anim/` folder, which is for View Animations). See [Animation Resources](http://developer.android.com/guide/topics/resources/animation-resource.html#Property) for full XML details
  ```xml
  <set android:ordering="together"> <!-- together is default -->

    <objectAnimator
             android:propertyName="x"
             android:duration="500"
             android:valueTo="400"
             android:valueType="intType"/>
    <!-- ... -->
  </set>
  ```
  Note that you'll need to **inflate** the Animator resource, just like we did with layouts:
  ```java
  ObjectAnimator anim = (ObjectAnimator) AnimatorInflater.loadAnimator(myContext, R.anim.animator);
  anim.setTarget(myObject);
  anim.start();
  ```

Note that we can also use this same framework to animate changes to `Views`: buttons, images, etc. Views are objects and have properties (along with getters and setters we can use)... so we can use just an `ObjectAnimator`! See [the docs](http://developer.android.com/guide/topics/graphics/prop-animation.html#views) for a list of properties we can change (includes `x, y, rotation, alpha, scaleX, scaleY`, etc.)

- Or to make this even simpler, Views provide a `ViewPropertyAnimator` which modifies multiple properties together, but does so in a much more efficient manner. We can access this with the `.animate()` method on a `View`, then call relevant methods that we want to change:

```java
myView.animate().x(100f).y(300f);
```

(But really, if you want to animate layout changes on a modern device, you should use [transitions](http://developer.android.com/training/transitions/index.html)), which makes this a lot easier (particularly for "normal" transitions)

There are [lots more ways](http://developer.android.com/guide/topics/graphics/prop-animation.html) to customize exactly what you want your animation to be, but this should give you a lot of the basics! You can also look at [official demos](https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/animation) for more examples.





---
---
---


## Implementing Material [30-40min]
//only available in Android 5.0 (API 21) or higher! Can get some pieces in lower APIs with backwards compatibility, but need to do some work https://developer.android.com/training/material/compatibility.html

**Material Theme** //cover in lab previously << recall from lab!

**Lists and Cards** [20min?]
- implementing RecyclerView??
- Providing a card view ((can do without the Recycler?))
>> should include this as well...

**Assigning Elevation** [5-10min]
- e.g., demo for buttons! (elevation + translation)
- how to change shape??
  - can move from rectangle to circle automatically? Check the `Outline` class...

**Animations** [30min? or skip?? (come back to later)]
- include some defaults (demo??)
- Do these need to be specified?
  - reveal
- transitions (e.g., between Fragments) are neat!
-
does Property Animation go here?... I think so (at least interpolation as a piece)... or do that set of transitions later (lab?)

**Drawables** ??
- meh


## Design Support Library [30-40mins]
- Floating Action Button [5min] << could be something to modify/demo with!
- Navigation Drawer (via support library; vs. v4 library? _what's the difference?_)
  - Not too bad: filling in XML (20min?)

- CoordinatorLayout omg wtf (go hog wild!!)
  - will need pictures/icons for... something?
